{"ts":1353638170461,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Connect - HTTPServer\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar http = require('http')\n  , utils = require('./utils')\n  , debug = require('debug')('connect:dispatcher');\n\n// prototype\n\nvar app = module.exports = {};\n\n// environment\n\nvar env = process.env.NODE_ENV || 'development';\n\n/**\n * Utilize the given middleware `handle` to the given `route`,\n * defaulting to _/_. This \"route\" is the mount-point for the\n * middleware, when given a value other than _/_ the middleware\n * is only effective when that segment is present in the request's\n * pathname.\n *\n * For example if we were to mount a function at _/admin_, it would\n * be invoked on _/admin_, and _/admin/settings_, however it would\n * not be invoked for _/_, or _/posts_.\n *\n * Examples:\n *\n *      var app = connect();\n *      app.use(connect.favicon());\n *      app.use(connect.logger());\n *      app.use(connect.static(__dirname + '/public'));\n *\n * If we wanted to prefix static files with _/public_, we could\n * \"mount\" the `static()` middleware:\n *\n *      app.use('/public', connect.static(__dirname + '/public'));\n *\n * This api is chainable, so the following is valid:\n *\n *      connect\n *        .use(connect.favicon())\n *        .use(connect.logger())\n *        .use(connect.static(__dirname + '/public'))\n *        .listen(3000);\n *\n * @param {String|Function|Server} route, callback or server\n * @param {Function|Server} callback or server\n * @return {Server} for chaining\n * @api public\n */\n\napp.use = function(route, fn){\n  // default route to '/'\n  if ('string' != typeof route) {\n    fn = route;\n    route = '/';\n  }\n\n  // wrap sub-apps\n  if ('function' == typeof fn.handle) {\n    var server = fn;\n    fn.route = route;\n    fn = function(req, res, next){\n      server.handle(req, res, next);\n    };\n  }\n\n  // wrap vanilla http.Servers\n  if (fn instanceof http.Server) {\n    fn = fn.listeners('request')[0];\n  }\n\n  // strip trailing slash\n  if ('/' == route[route.length - 1]) {\n    route = route.slice(0, -1);\n  }\n\n  // add the middleware\n  debug('use %s %s', route || '/', fn.name || 'anonymous');\n  this.stack.push({ route: route, handle: fn });\n\n  return this;\n};\n\n/**\n * Handle server requests, punting them down\n * the middleware stack.\n *\n * @api private\n */\n\napp.handle = function(req, res, out) {\n  var stack = this.stack\n    , fqdn = ~req.url.indexOf('://')\n    , removed = ''\n    , slashAdded = false\n    , index = 0;\n\n  function next(err) {\n    var layer, path, status, c;\n\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    req.url = removed + req.url;\n    req.originalUrl = req.originalUrl || req.url;\n    removed = '';\n\n    // next callback\n    layer = stack[index++];\n\n    // all done\n    if (!layer || res.headerSent) {\n      // delegate to parent\n      if (out) return out(err);\n\n      // unhandled error\n      if (err) {\n        // default to 500\n        if (res.statusCode < 400) res.statusCode = 500;\n        debug('default %s', res.statusCode);\n\n        // respect err.status\n        if (err.status) res.statusCode = err.status;\n\n        // production gets a basic error message\n        var msg = 'production' == env\n          ? http.STATUS_CODES[res.statusCode]\n          : err.stack || err.toString();\n\n        // log to stderr in a non-test env\n        if ('test' != env) console.error(err.stack || err.toString());\n        if (res.headerSent) return req.socket.destroy();\n        res.setHeader('Content-Type', 'text/plain');\n        res.setHeader('Content-Length', Buffer.byteLength(msg));\n        if ('HEAD' == req.method) return res.end();\n        res.end(msg);\n      } else {\n        debug('default 404');\n        res.statusCode = 404;\n        res.setHeader('Content-Type', 'text/plain');\n        if ('HEAD' == req.method) return res.end();\n        res.end('Cannot ' + req.method + ' ' + utils.escape(req.originalUrl));\n      }\n      return;\n    }\n\n    try {\n      path = utils.parseUrl(req).pathname;\n      if (undefined == path) path = '/';\n\n      // skip this layer if the route doesn't match.\n      if (0 != path.indexOf(layer.route)) return next(err);\n\n      c = path[layer.route.length];\n      if (c && '/' != c && '.' != c) return next(err);\n\n      // Call the layer handler\n      // Trim off the part of the url that matches the route\n      removed = layer.route;\n      req.url = req.url.substr(removed.length);\n\n      // Ensure leading slash\n      if (!fqdn && '/' != req.url[0]) {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      debug('%s', layer.handle.name || 'anonymous');\n      var arity = layer.handle.length;\n      if (err) {\n        if (arity === 4) {\n          layer.handle(err, req, res, next);\n        } else {\n          next(err);\n        }\n      } else if (arity < 4) {\n        layer.handle(req, res, next);\n      } else {\n        next();\n      }\n    } catch (e) {\n      next(e);\n    }\n  }\n  next();\n};\n\n/**\n * Listen for connections.\n *\n * This method takes the same arguments\n * as node's `http.Server#listen()`.  \n *\n * HTTP and HTTPS:\n *\n * If you run your application both as HTTP\n * and HTTPS you may wrap them individually,\n * since your Connect \"server\" is really just\n * a JavaScript `Function`.\n *\n *      var connect = require('connect')\n *        , http = require('http')\n *        , https = require('https');\n *      \n *      var app = connect();\n *      \n *      http.createServer(app).listen(80);\n *      https.createServer(options, app).listen(443);\n *\n * @return {http.Server}\n * @api public\n */\n\napp.listen = function(){\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":5723}]],"length":5723}
