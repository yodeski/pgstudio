{"ts":1353638166914,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n/*!\n * Connect - session\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar Session = require('./session/session')\n  , debug = require('debug')('connect:session')\n  , MemoryStore = require('./session/memory')\n  , Cookie = require('./session/cookie')\n  , Store = require('./session/store')\n  , utils = require('./../utils')\n  , parse = utils.parseUrl\n  , crc16 = require('crc').crc16\n  , crypto = require('crypto');\n\n// environment\n\nvar env = process.env.NODE_ENV;\n\n/**\n * Expose the middleware.\n */\n\nexports = module.exports = session;\n\n/**\n * Expose constructors.\n */\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n\n/**\n * Warning message for `MemoryStore` usage in production.\n */\n\nvar warning = 'Warning: connection.session() MemoryStore is not\\n'\n  + 'designed for a production environment, as it will leak\\n'\n  + 'memory, and will not scale past a single process.';\n\n/**\n * Session:\n * \n *   Setup session store with the given `options`.\n *\n *   Session data is _not_ saved in the cookie itself, however\n *   cookies are used, so we must use the [cookieParser()](cookieParser.html)\n *   middleware _before_ `session()`.\n *\n * Examples:\n *\n *     connect()\n *       .use(connect.cookieParser())\n *       .use(connect.session({ secret: 'keyboard cat', key: 'sid', cookie: { secure: true }}))\n *\n * Options:\n *\n *   - `key` cookie name defaulting to `connect.sid`\n *   - `store` session store instance\n *   - `secret` session cookie is signed with this secret to prevent tampering\n *   - `cookie` session cookie settings, defaulting to `{ path: '/', httpOnly: true, maxAge: null }`\n *   - `proxy` trust the reverse proxy when setting secure cookies (via \"x-forwarded-proto\")\n *\n * Cookie option:\n *\n *  By default `cookie.maxAge` is `null`, meaning no \"expires\" parameter is set\n *  so the cookie becomes a browser-session cookie. When the user closes the \n *  browser the cookie (and session) will be removed.\n *\n * ## req.session\n *\n *  To store or access session data, simply use the request property `req.session`,\n *  which is (generally) serialized as JSON by the store, so nested objects \n *  are typically fine. For example below is a user-specific view counter:\n *\n *       connect()\n *         .use(connect.favicon())\n *         .use(connect.cookieParser())\n *         .use(connect.session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }}))\n *         .use(function(req, res, next){\n *           var sess = req.session;\n *           if (sess.views) {\n *             res.setHeader('Content-Type', 'text/html');\n *             res.write('<p>views: ' + sess.views + '</p>');\n *             res.write('<p>expires in: ' + (sess.cookie.maxAge / 1000) + 's</p>');\n *             res.end();\n *             sess.views++;\n *           } else {\n *             sess.views = 1;\n *             res.end('welcome to the session demo. refresh!');\n *           }\n *         }\n *       )).listen(3000);\n *\n * ## Session#regenerate()\n *\n *  To regenerate the session simply invoke the method, once complete\n *  a new SID and `Session` instance will be initialized at `req.session`.\n *\n *      req.session.regenerate(function(err){\n *        // will have a new session here\n *      });\n *\n * ## Session#destroy()\n *\n *  Destroys the session, removing `req.session`, will be re-generated next request.\n *\n *      req.session.destroy(function(err){\n *        // cannot access session here\n *      });\n * \n * ## Session#reload()\n *\n *  Reloads the session data.\n *\n *      req.session.reload(function(err){\n *        // session updated\n *      });\n *\n * ## Session#save()\n *\n *  Save the session.\n *\n *      req.session.save(function(err){\n *        // session saved\n *      });\n *\n * ## Session#touch()\n *\n *   Updates the `.maxAge` property. Typically this is\n *   not necessary to call, as the session middleware does this for you.\n *\n * ## Session#cookie\n *\n *  Each session has a unique cookie object accompany it. This allows\n *  you to alter the session cookie per visitor. For example we can\n *  set `req.session.cookie.expires` to `false` to enable the cookie\n *  to remain for only the duration of the user-agent.\n *\n * ## Session#maxAge\n *\n *  Alternatively `req.session.cookie.maxAge` will return the time\n *  remaining in milliseconds, which we may also re-assign a new value\n *  to adjust the `.expires` property appropriately. The following\n *  are essentially equivalent\n *\n *     var hour = 3600000;\n *     req.session.cookie.expires = new Date(Date.now() + hour);\n *     req.session.cookie.maxAge = hour;\n *\n * For example when `maxAge` is set to `60000` (one minute), and 30 seconds\n * has elapsed it will return `30000` until the current request has completed,\n * at which time `req.session.touch()` is called to reset `req.session.maxAge`\n * to its original value.\n *\n *     req.session.cookie.maxAge;\n *     // => 30000\n *\n * Session Store Implementation:\n *\n * Every session store _must_ implement the following methods\n *\n *    - `.get(sid, callback)`\n *    - `.set(sid, session, callback)`\n *    - `.destroy(sid, callback)`\n *\n * Recommended methods include, but are not limited to:\n *\n *    - `.length(callback)`\n *    - `.clear(callback)`\n *\n * For an example implementation view the [connect-redis](http://github.com/visionmedia/connect-redis) repo.\n *\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nfunction session(options){\n  var options = options || {}\n    , key = options.key || 'connect.sid'\n    , store = options.store || new MemoryStore\n    , cookie = options.cookie || {}\n    , trustProxy = options.proxy;\n\n  // notify user that this store is not\n  // meant for a production environment\n  if ('production' == env && store instanceof MemoryStore) {\n    console.warn(warning);\n  }\n\n  // generates the new session\n  store.generate = function(req){\n    req.sessionID = utils.uid(24);\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookie);\n  };\n\n  return function session(req, res, next) {\n    // self-awareness\n    if (req.session) return next();\n\n    // pathname mismatch\n    if (0 != req.originalUrl.indexOf(cookie.path || '/')) return next();\n\n    // backwards compatibility for signed cookies\n    // req.secret is passed from the cookie parser middleware\n    var secret = options.secret || req.secret;\n\n    // ensure secret is available or bail\n    if (!secret) throw new Error('`secret` option required for sessions');\n\n    // parse url\n    var url = parse(req)\n      , path = url.pathname\n      , originalHash;\n\n    // expose store\n    req.sessionStore = store;\n\n    // grab the session cookie value and check the signature\n    var rawCookie = req.cookies[key];\n\n    // get signedCookies for backwards compat with signed cookies\n    var unsignedCookie = req.signedCookies[key];\n\n    if (!unsignedCookie && rawCookie) {\n      unsignedCookie = utils.parseSignedCookie(rawCookie, secret);\n    }\n\n    // set-cookie\n    res.on('header', function(){\n      if (!req.session) return;\n      var cookie = req.session.cookie\n        , proto = (req.headers['x-forwarded-proto'] || '').toLowerCase()\n        , tls = req.connection.encrypted || (trustProxy && 'https' == proto)\n        , secured = cookie.secure && tls\n        , isNew = unsignedCookie != req.sessionID;\n\n      // only send secure cookies via https\n      if (cookie.secure && !secured) return debug('not secured');\n\n      // browser-session length cookie\n      if (null == cookie.expires) {\n        if (!isNew) return debug('already set browser-session cookie');\n      // compare hashes\n      } else if (originalHash == hash(req.session)) {\n        return debug('unmodified session');\n      }\n\n      var val = 's:' + utils.sign(req.sessionID, secret);\n      val = cookie.serialize(key, val);\n      debug('set-cookie %s', val);\n      res.setHeader('Set-Cookie', val);\n    });\n\n    // proxy end() to commit the session\n    var end = res.end;\n    res.end = function(data, encoding){\n      res.end = end;\n      if (!req.session) return res.end(data, encoding);\n      debug('saving');\n      req.session.resetMaxAge();\n      req.session.save(function(){\n        debug('saved');\n        res.end(data, encoding);\n      });\n    };\n\n    // generate the session\n    function generate() {\n      store.generate(req);\n    }\n\n    // get the sessionID from the cookie\n    req.sessionID = unsignedCookie;\n\n    // generate a session if the browser doesn't send a sessionID\n    if (!req.sessionID) {\n      debug('no SID sent, generating session');\n      generate();\n      next();\n      return;\n    }\n\n    // generate the session object\n    var pause = utils.pause(req);\n    debug('fetching %s', req.sessionID);\n    store.get(req.sessionID, function(err, sess){\n      // proxy to resume() events\n      var _next = next;\n      next = function(err){\n        _next(err);\n        pause.resume();\n      }\n\n      // error handling\n      if (err) {\n        debug('error');\n        if ('ENOENT' == err.code) {\n          generate();\n          next();\n        } else {\n          next(err);\n        }\n      // no session\n      } else if (!sess) {\n        debug('no session found');\n        generate();\n        next();\n      // populate req.session\n      } else {\n        debug('session found');\n        store.createSession(req, sess);\n        originalHash = hash(sess);\n        next();\n      }\n    });\n  };\n};\n\n/**\n * Hash the given `sess` object omitting changes\n * to `.cookie`.\n *\n * @param {Object} sess\n * @return {String}\n * @api private\n */\n\nfunction hash(sess) {\n  return crc16(JSON.stringify(sess, function(key, val){\n    if ('cookie' != key) return val;\n  }));\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":9714}]],"length":9714}
