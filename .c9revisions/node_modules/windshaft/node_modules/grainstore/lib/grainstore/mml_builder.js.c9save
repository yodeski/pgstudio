{"ts":1353442136638,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var _      = require('underscore'),\n    base64 = require('./base64'),\n    Step   = require('step'),\n    carto  = require('carto'),\n    millstone = require('millstone'),\n    fs     = require('fs'),\n    StyleTrans = require('./style_trans'),\n    semver = require('semver')\n;\n\n// MML builder interface\n//\n// `redis` should be an instance of RedisPool\n//\n// opts must have:\n// `dbname`    - name of database\n// `table` - name of table with geospatial data\n// \n// opts may have:\n// `sql`             - sql to constrain the map by\n// `geom_type`       - [polygon|point] to specify which default style to use\n// `style`           - Carto style to override the built in style store\n// `style_version`   - Version of the carto style override\n// `mapnik_version`  - Target version of mapnik, defaults to ``latest``\n//\n// @param optional_args\n//     You may pass in a third argument to override grainstore defaults. \n//     `map` specifies the output map projection.\n//     `datasource` specifies postgis details from Mapnik postgis plugin:\n//                  https://github.com/mapnik/mapnik/wiki \n//     `styles` specifies the default styles\n//     `cachedir` is base directory to put localized external resources into\n//\n//     eg.\n//     {\n//       map: {srid: 3857},\n//       datasource: {\n//         type: \"postgis\",\n//         host: \"localhost\",\n//         user: \"postgres\",\n//         geometry_field: \"the_geom_webmercator\",\n//         extent: \"-20005048.4188,-20005048.4188,20005048.4188,20005048.4188\",\n//         srid: 3857,\n//         max_size: 10\n//       },\n//       styles: {\n//         point: \"default point style\",\n//         polygon: \"default polygon style\",  \n//       }\n//     }\n//\n// @param init_callback\n//   init_callback(err, payload) will be invoked on complete initialization\n//   see me.init for more info\n//\nvar MMLBuilder = function(redis_pool, opts, optional_args, init_callback){\n\n    // The init_callback parameter is optional\n    init_callback = init_callback || function() {};\n\n    // core variables\n    var opts = opts || {};\n    var opt_keys = _.keys(opts);\n    if (!_.include(opt_keys,'dbname') || !_.include(opt_keys, 'table'))\n        throw new Error(\"Options must include dbname and table\");\n    var geom_type      = opts.geom_type || 'point';   // geom type for default styling\n\n    var extra_config          = optional_args           || {};\n\n    var target_mapnik_version = extra_config.mapnik_version || '2.0.2';\n    var default_style_version = extra_config.default_style_version || '2.0.0';\n\n    // configure grainstore from optional args passed + defaults\n    var grainstore_defaults = {\n        map: {\n            srid: 3857\n        },\n        datasource: {\n            type: \"postgis\",\n            host: \"localhost\",\n            user: \"postgres\",\n            geometry_field: \"the_geom_webmercator\",\n            extent: \"-20005048.4188,-20005048.4188,20005048.4188,20005048.4188\",\n            srid: 3857,\n            max_size: 10\n        },\n        styles: {\n            db: 0  // redis database to store styles\n        }\n    };\n\n    if ( semver.satisfies(target_mapnik_version, '< 2.1.0') )\n    {\n      var def_style_point = \" {marker-fill: #FF6600;marker-opacity: 1;marker-width: 8;marker-line-color: white;marker-line-width: 3;marker-line-opacity: 0.9;marker-placement: point;marker-type: ellipse;marker-allow-overlap: true;}\";\n      var def_style_line = \" {line-color:#FF6600; line-width:1; line-opacity: 0.7;}\";\n      var def_style_poly = \" {polygon-fill:#FF6600; polygon-opacity: 0.7; line-opacity:1; line-color: #FFFFFF;}\";\n      grainstore_defaults.styles.point = '#' + opts.table + def_style_point;\n      grainstore_defaults.styles.polygon = '#' + opts.table + def_style_poly;\n      grainstore_defaults.styles.multipolygon = grainstore_defaults.styles.polygon;\n      grainstore_defaults.styles.multilinestring = '#' + opts.table + def_style_line;\n      grainstore_defaults.styles.version = '2.0.0';\n    }\n    else\n    {\n      var def_style_point = \" {marker-fill: #FF6600;marker-opacity: 1;marker-width: 16;marker-line-color: white;marker-line-width: 3;marker-line-opacity: 0.9;marker-placement: point;marker-type: ellipse;marker-allow-overlap: true;}\";\n      var def_style_line = \" {line-color:#FF6600; line-width:1; line-opacity: 0.7;}\";\n      var def_style_poly = \" {polygon-fill:#FF6600; polygon-opacity: 0.7; line-opacity:1; line-color: #FFFFFF;}\";\n\n      grainstore_defaults.styles.point = \n        grainstore_defaults.styles.polygon = \n        grainstore_defaults.styles.multipolygon = \n        grainstore_defaults.styles.multilinestring = \n        grainstore_defaults.styles.geometry = \n        '#' + opts.table + '[mapnik-geometry-type=1]' + def_style_point +\n        '#' + opts.table + '[mapnik-geometry-type=2]' + def_style_line +\n        '#' + opts.table + '[mapnik-geometry-type=3]' + def_style_poly\n      ;\n      grainstore_defaults.styles.version = '2.1.0';\n    }\n\n    var grainstore_map        = extra_config.map        || {};\n    // NOTE: we clone this to avoid changing default settings with an override\n    var grainstore_datasource = extra_config.datasource ? _.clone(extra_config.datasource) : {};\n    var grainstore_styles     = extra_config.styles     || {};\n\n    grainstore_map        = _.defaults(grainstore_map, grainstore_defaults.map);\n    grainstore_datasource = _.defaults(grainstore_datasource, grainstore_defaults.datasource);\n    grainstore_styles     = _.defaults(grainstore_styles, grainstore_defaults.styles);\n\n    // Allow overriding db authentication with options\n    if ( opts.dbuser ) grainstore_datasource.user = opts.dbuser;\n    if ( opts.dbpassword ) grainstore_datasource.password = opts.dbpassword;\n\n    // Millstone configuration\n    //\n    // Localized resources are not shared between \"layers\",\n    // so we can safely purge them whenever redis keys for the style\n    // are purged (setStyle, delStyle)\n    //\n    var millstone_cachedir = extra_config.cachedir || '/tmp/millstone'; \n        millstone_cachedir += '/' + opts.dbname + '/' + opts.table;\n    var millstone_base_options = {\n        base:  millstone_cachedir +  '/base',\n        cache: millstone_cachedir + '/cache'\n    };\n\n    // MML Builder definition\n    var me = {};\n\n    // setup XML for this object in Redis. Either from base, or from defaults.\n    //\n    // @param callback(err, style_payload) gets called with the string version\n    //        of the style payload, which can be parsed by JSON.parse\n    //\n    me.init = function(callback){\n        var that = this;\n        var store_key = extended_store_key || base_store_key;\n        var redis_client;\n        var style;\n        var style_version;\n        var xml;\n        var xml_version;\n        var style_only_in_base = ( store_key != base_store_key && _.isNull(style_override) );\n\n        Step(\n            function getRedisClient(){\n                redis_pool.acquire(grainstore_styles.db, this);\n            },\n            function getStyleAndXML(err, data){\n                if (err) throw err;\n                redis_client = data;\n                redis_client.GET(store_key, this);\n            },\n            function initCheck(err, data){\n                if (err) throw err;\n\n                do { \n\n                  if (_.isNull(data)) break; // no redis record\n\n                  var record = JSON.parse(data);\n                  if ( ! record.xml ) break; // no XML in record\n\n                  if ( ! record.xml_version ) break; // no xml_version in record\n\n                  // XML target mapnik version mismatch\n                  if ( record.xml_version != target_mapnik_version ) break;\n\n                  // All checks passed, nothing more to do here\n                  if (!_.isUndefined(redis_client))\n                      redis_pool.release(grainstore_styles.db, redis_client);\n                  callback(err, data);\n                  return;\n\n                } while (0);\n\n                // XML needs to be re-generated, go on\n                if ( !_.isNull(style_override) ) return null;\n\n                // Keep an eye on base_store_key so that if anyone\n                // changes the base style we don't override the\n                // rendered ones.\n                // See https://github.com/Vizzuality/grainstore/issues/27\n                redis_client.WATCH(base_store_key);\n                redis_client.GET(base_store_key, this);\n                return;\n\n            },\n            function renderBaseStyleOrDefaultOrOverride(err, data){\n                if (err) throw err;\n                if (_.isNull(data)){\n                    if ( ! grainstore_styles.hasOwnProperty(geom_type) ) {\n                      throw new Error(\"No style available for geometry of type '\" + geom_type + \"'\"); \n                    }\n                    style = grainstore_styles[geom_type];\n                    style_version = grainstore_styles['version'];\n                } else {\n                    var parsed = JSON.parse(data);\n                    style = parsed.style;\n                    style_version = parsed.version || default_style_version;\n                }\n                if (!_.isNull(style_override)){\n                    style = style_override;\n                    style_version = style_version_override;\n                }\n                that.render(style, this, style_version);\n            },\n            function setStore(err, compiled_XML){\n                if (err) throw err;\n                xml = compiled_XML;\n                var tostore = {xml: compiled_XML, xml_version: target_mapnik_version };\n                if ( store_key == base_store_key ) {\n                  tostore.style = style;\n                  tostore.version = style_version;\n                }\n                var payload = JSON.stringify(tostore);\n                var redis_transaction = redis_client.MULTI();\n                redis_transaction.SET(store_key, payload);\n                if ( style_only_in_base ) { \n                  var tostore = {style: style, version: style_version};\n                  var payload = JSON.stringify(tostore);\n                  redis_transaction.SET(base_store_key, payload, this);\n                }\n                // This transaction will have NO effect IFF\n                // the value of base_store_key changed since we\n                // looked at it. See WATCH above.\n                redis_transaction.EXEC(this);\n            },\n            function callbackExit(err, data){\n                // NOTE: data will be an array of responses\n                //       from each of the commands sent in\n                //       the transaction above.\n                if (!_.isUndefined(redis_client))\n                    redis_pool.release(grainstore_styles.db, redis_client);\n                callback(err, JSON.stringify({style: style, xml: xml}));\n            }\n        );\n    };\n\n\n    // render CartoCSS to Mapnik XML\n    //\n    // @param style the CartoCSS\n    // @param version the version of the given CartoCSS\n    // \n    me.render = function(style, callback, version){\n\n        if ( ! version ) version = default_style_version;\n\n        if ( version != target_mapnik_version ) {\n          try {\n            var t = new StyleTrans();\n            style = t.transform(style, version, target_mapnik_version);\n          }\n          catch (err) {\n            callback(err, null);\n            return;\n          }\n        }\n\n        var mml = this.toMML(style);\n\n        var millstone_options = _.extend({mml:mml}, millstone_base_options);\n        millstone.resolve(millstone_options, function(err, mml) {\n//console.log(\"Resolved mml: \"); console.dir(mml);\n\n          if ( err ) {\n            callback(err, null);\n            return;\n          }\n\n          var carto_env = {};\n          var carto_options = { mapnik_version: target_mapnik_version };\n\n          // carto.Renderer may throw during parse time (before nextTick is called)\n          // See https://github.com/mapbox/carto/pull/187\n          try { \n          new carto.Renderer(carto_env, carto_options).render(mml, function(err, output){\n              callback(err, output);\n          });\n          } catch (err) { callback(err, null); }\n\n        });\n\n\n    };\n\n\n    // Purge cache of localized resources for this store\n    me.purgeLocalizedResourceCache = function(callback)\n    {\n      // TODO: check if \"base\" should also be cleared\n      var toclear = millstone_cachedir + '/cache';\n      fs.readdir(toclear, function(err, files) {\n        if ( err ) {\n          if ( err.code != 'ENOENT' ) callback(err)\n          else callback(null); // nothing to clear\n        }\n        else {\n          var left = files.length;\n          if ( ! left ) callback(null);\n          _.each(files, function(name) {\n            var file = toclear + '/' + name;\n            //console.log(\"Unlinking \" + file);\n            fs.unlink(file, function(err) {\n              if (err) console.log(\"Error unlinking \" + file + \": \" + err);\n              if ( ! --left ) callback(null);\n            });\n          });\n        }\n      });\n    };\n\n    // Re-generate Mapnik XML from current MML.\n    me.resetStyle = function(callback, convert){\n      var that = this;\n      that.getStyle(function(err, style) {\n        return that.setStyle(style.style, callback, style.version, convert);\n      });\n    };\n\n    // Generate Mapnik XML from MML.\n    // store passed style and generated XML\n    // Pass back any cartocss compile errors\n    //\n    // generates XML and stores it on base key\n    // deletes all associated extended_store_keys as they\n    // need to be regenerated\n    me.setStyle = function(style, callback, version, convert){\n        var that = this\n            , redis_client\n            , compiled_XML;\n\n        if ( ! version ) version = default_style_version;\n\n        if ( convert && version != target_mapnik_version ) {\n          try {\n            var t = new StyleTrans();\n            style = t.transform(style, version, target_mapnik_version);\n            version = target_mapnik_version;\n          }\n          catch (err) {\n            callback(err, null);\n            return;\n          }\n        }\n\n        Step(\n            // Purge millstone cache before refilling it\n            function purgeCache(){\n                that.purgeLocalizedResourceCache(this);\n            },\n            function renderMapnikStylesheet(err){\n                if (err) throw err;\n                that.render(style, this, version);\n            },\n            function getRedisClient(err, data){\n                if (err) throw err;\n                compiled_XML = data;\n                redis_pool.acquire(grainstore_styles.db, this);\n            },\n            function storeStyleAndXML(err, data){\n                if (err) throw err;\n                redis_client = data;\n                if ( _.isNull(style_override) )  {\n                  redis_client.SET(base_store_key, JSON.stringify({\n                    style: style,\n                    version: version,\n                    xml: compiled_XML,\n                    xml_version: target_mapnik_version}), this);\n                } else {\n                  // Don't bother setting anything in redis as redis keys\n                  // are going to be killed anyway, but tweak the\n                  // extended_store_key anyway so next call to toXML\n                  // won't recreate the old key\n                  style_override = style;\n                  style_version_override = version;\n                  extended_store_key = that.makeExtendedKey();\n                  return null;\n                }\n            },\n            function getRelatedKeys(err, data){\n                if (err) throw err;\n                redis_client.KEYS(base_store_key + '|*', this);\n            },\n            function deleteRelatedKeys(err, data){\n                if (err) throw err;\n                if (_.isEmpty(data)) {\n                    return null;\n                } else {\n                    redis_client.DEL(data, this);\n                }\n            },\n            function callbackExit(err, data){\n                if (!_.isUndefined(redis_client))\n                    redis_pool.release(grainstore_styles.db, redis_client);\n                callback(err, data);\n            }\n        );\n    };\n\n    // Delete style caches from redis\n    // NOTE: deletes both _base_ and _related_ keys\n    me.delStyle = function(callback){\n        var that = this\n            , redis_client;\n\n        Step(\n            // Purge millstone cache before refilling it\n            function purgeCache(){\n                that.purgeLocalizedResourceCache(this);\n            },\n            function getRedisClient(err){\n                if (err) throw err;\n                redis_pool.acquire(grainstore_styles.db, this);\n            },\n            function DelStyleAndXML(err, data){\n                if (err) throw err;\n                redis_client = data;\n                redis_client.DEL(base_store_key, this);\n            },\n            function getRelatedKeys(err, data){\n                if (err) throw err;\n                redis_client.KEYS(base_store_key + '|*', this);\n            },\n            function deleteRelatedKeys(err, data){\n                if (err) throw err;\n                if (_.isEmpty(data)) {\n                    return null;\n                } else {\n                    redis_client.DEL(data, this);\n                }\n            },\n            function callbackExit(err, data){\n                if (!_.isUndefined(redis_client))\n                    redis_pool.release(grainstore_styles.db, redis_client);\n                callback(err, data);\n            }\n        );\n    };\n\n    // @param callback function(err, payload)\n    //                 The payload is an object containing\n    //                 \"style\" (CartoCSS) and \"version\" members\n    //\n    // @param convert if true it will return the style in the configured\n    //                target mapnik version\n    me.getStyle = function(callback, convert){\n        var that = this;\n        var redis_client;\n\n        Step(\n            function initStyle(){\n                that.init(this);\n            },\n            function getRedisClient(err, data){\n                if (err) throw err;\n                redis_pool.acquire(grainstore_styles.db, this);\n            },\n            function getStyleAndXML(err, data){\n                if (err) throw err;\n                redis_client = data;\n                redis_client.GET(base_store_key, this);\n            },\n            function callbackExit(err, data){\n                if (!_.isUndefined(redis_client))\n                    redis_pool.release(grainstore_styles.db, redis_client);\n                if ( err ) { callback(err, null); return; }\n                var parsed = JSON.parse(data);\n                if ( convert && parsed.version != target_mapnik_version ) {\n                  var t = new StyleTrans();\n                  parsed.style = t.transform(parsed.style, parsed.version, target_mapnik_version);\n                  parsed.version = target_mapnik_version;\n                }\n                callback(err, parsed);\n            }\n        );\n    };\n\n\n    me.toXML = function(callback){\n        this.init(function(err, data) {\n            if (err) {\n                callback(err, null);\n            } else {\n                callback(err, JSON.parse(data).xml);\n            }\n        });\n    };\n\n    me.toMML = function(style){\n        var stylesheet  = {};\n        stylesheet.id   = 'style.mss';\n        stylesheet.data = style;\n\n        var base_mml = this.baseMML();\n        base_mml.Stylesheet = [stylesheet];\n\n        return base_mml;\n    };\n\n\n    // Generate base MML for this object\n    // opts:\n    // `use_sql` - {Boolean} if true, use sql settings in MML, else use table\n    me.baseMML = function(args){\n        args = args || {};\n        args = _.defaults(args, {use_sql: true});\n\n        var datasource     = _.clone(grainstore_datasource);\n        datasource.table   = (args.use_sql && !_.isUndefined(opts.sql)) ? opts.sql : opts.table;\n        datasource.dbname  = opts.dbname;\n\n        var layer        = {};\n        layer.id         = opts.table;\n        layer.name       = opts.table;\n        layer.srs        = '+init=epsg:' + grainstore_datasource.srid; //layer.srs = srs.parse(layer.srs).proj4;\n        layer.Datasource = datasource;\n\n        var mml   = {};\n        mml.srs   = '+init=epsg:' + grainstore_map.srid; // mml.srs = srs.parse(mml.srs).proj4;\n        mml.Layer = [layer];\n\n        return mml;\n    };\n\n    // Bases extended key on:\n    //   base_store_key\n    //   opts.sql\n    //   style_override\n    //   style_version_override\n    //  \n    me.makeExtendedKey = function() {\n      if ( ! opts.sql && ! style_override ) return; // no extended key needed\n      var key = base_store_key;\n      if ( opts.sql ) key += '|' + base64.encode(opts.sql);\n      if ( style_override ) key += '|' + base64.encode(style_override + '|' + style_version_override);\n      return key;\n    }\n\n    var style_override = opts.style ? opts.style : null;\n    var style_version_override = opts.style_version ? opts.style_version : default_style_version;\n\n    // Redis storage keys\n    var base_store_key = 'map_style' + '|' + opts.dbname + '|' + opts.table;\n    var extended_store_key = me.makeExtendedKey();\n\n    //trigger constructor\n    me.init(init_callback);\n\n    return me;\n};\n\nmodule.exports = MMLBuilder;\n"]],"start1":0,"start2":0,"length1":0,"length2":21349}]],"length":21349}
